
// AUTO GENERATED by vnxcppcodegen

#include <vnx/test/package.hxx>
#include <vnx/test/TestValue.hxx>
#include <vnx/User.hxx>
#include <vnx/Value.h>
#include <vnx/Variant.hpp>
#include <vnx/permission_e.hxx>
#include <vnx/test/test_struct_t.hxx>

#include <vnx/vnx.h>


namespace vnx {
namespace test {


const vnx::Hash64 TestValue::VNX_TYPE_HASH(0x8330d2d961c9571cull);
const vnx::Hash64 TestValue::VNX_CODE_HASH(0xb725c92956db303eull);

vnx::Hash64 TestValue::get_type_hash() const {
	return VNX_TYPE_HASH;
}

std::string TestValue::get_type_name() const {
	return "vnx.test.TestValue";
}

const vnx::TypeCode* TestValue::get_type_code() const {
	return vnx::test::vnx_native_type_code_TestValue;
}

std::shared_ptr<TestValue> TestValue::create() {
	return std::make_shared<TestValue>();
}

std::shared_ptr<vnx::Value> TestValue::clone() const {
	return std::make_shared<TestValue>(*this);
}

void TestValue::read(vnx::TypeInput& _in, const vnx::TypeCode* _type_code, const uint16_t* _code) {
	vnx::read(_in, *this, _type_code, _code);
}

void TestValue::write(vnx::TypeOutput& _out, const vnx::TypeCode* _type_code, const uint16_t* _code) const {
	vnx::write(_out, *this, _type_code, _code);
}

void TestValue::accept(vnx::Visitor& _visitor) const {
	const vnx::TypeCode* _type_code = vnx::test::vnx_native_type_code_TestValue;
	_visitor.type_begin(*_type_code);
	_visitor.type_field(_type_code->fields[0], 0); vnx::accept(_visitor, bool_);
	_visitor.type_field(_type_code->fields[1], 1); vnx::accept(_visitor, int_);
	_visitor.type_field(_type_code->fields[2], 2); vnx::accept(_visitor, double_);
	_visitor.type_field(_type_code->fields[3], 3); vnx::accept(_visitor, array_);
	_visitor.type_field(_type_code->fields[4], 4); vnx::accept(_visitor, struct_array_);
	_visitor.type_field(_type_code->fields[5], 5); vnx::accept(_visitor, tmpl_array_);
	_visitor.type_field(_type_code->fields[6], 6); vnx::accept(_visitor, string_);
	_visitor.type_field(_type_code->fields[7], 7); vnx::accept(_visitor, tuple_);
	_visitor.type_field(_type_code->fields[8], 8); vnx::accept(_visitor, user_tuple_);
	_visitor.type_field(_type_code->fields[9], 9); vnx::accept(_visitor, vector_);
	_visitor.type_field(_type_code->fields[10], 10); vnx::accept(_visitor, user_vector_);
	_visitor.type_field(_type_code->fields[11], 11); vnx::accept(_visitor, variant_vector_);
	_visitor.type_field(_type_code->fields[12], 12); vnx::accept(_visitor, enum_vector_);
	_visitor.type_field(_type_code->fields[13], 13); vnx::accept(_visitor, pair_vector_);
	_visitor.type_field(_type_code->fields[14], 14); vnx::accept(_visitor, set_);
	_visitor.type_field(_type_code->fields[15], 15); vnx::accept(_visitor, map_);
	_visitor.type_field(_type_code->fields[16], 16); vnx::accept(_visitor, variant_);
	_visitor.type_field(_type_code->fields[17], 17); vnx::accept(_visitor, struct_);
	_visitor.type_field(_type_code->fields[18], 18); vnx::accept(_visitor, enum_);
	_visitor.type_field(_type_code->fields[19], 19); vnx::accept(_visitor, user_);
	_visitor.type_field(_type_code->fields[20], 20); vnx::accept(_visitor, pointer_);
	_visitor.type_field(_type_code->fields[21], 21); vnx::accept(_visitor, optional_int_);
	_visitor.type_field(_type_code->fields[22], 22); vnx::accept(_visitor, optional_struct_);
	_visitor.type_field(_type_code->fields[23], 23); vnx::accept(_visitor, optional_enum_);
	_visitor.type_field(_type_code->fields[24], 24); vnx::accept(_visitor, optional_vector_);
	_visitor.type_end(*_type_code);
}

void TestValue::write(std::ostream& _out) const {
	_out << "{\"__type\": \"vnx.test.TestValue\"";
	_out << ", \"bool_\": "; vnx::write(_out, bool_);
	_out << ", \"int_\": "; vnx::write(_out, int_);
	_out << ", \"double_\": "; vnx::write(_out, double_);
	_out << ", \"array_\": "; vnx::write(_out, array_);
	_out << ", \"struct_array_\": "; vnx::write(_out, struct_array_);
	_out << ", \"tmpl_array_\": "; vnx::write(_out, tmpl_array_);
	_out << ", \"string_\": "; vnx::write(_out, string_);
	_out << ", \"tuple_\": "; vnx::write(_out, tuple_);
	_out << ", \"user_tuple_\": "; vnx::write(_out, user_tuple_);
	_out << ", \"vector_\": "; vnx::write(_out, vector_);
	_out << ", \"user_vector_\": "; vnx::write(_out, user_vector_);
	_out << ", \"variant_vector_\": "; vnx::write(_out, variant_vector_);
	_out << ", \"enum_vector_\": "; vnx::write(_out, enum_vector_);
	_out << ", \"pair_vector_\": "; vnx::write(_out, pair_vector_);
	_out << ", \"set_\": "; vnx::write(_out, set_);
	_out << ", \"map_\": "; vnx::write(_out, map_);
	_out << ", \"variant_\": "; vnx::write(_out, variant_);
	_out << ", \"struct_\": "; vnx::write(_out, struct_);
	_out << ", \"enum_\": "; vnx::write(_out, enum_);
	_out << ", \"user_\": "; vnx::write(_out, user_);
	_out << ", \"pointer_\": "; vnx::write(_out, pointer_);
	_out << ", \"optional_int_\": "; vnx::write(_out, optional_int_);
	_out << ", \"optional_struct_\": "; vnx::write(_out, optional_struct_);
	_out << ", \"optional_enum_\": "; vnx::write(_out, optional_enum_);
	_out << ", \"optional_vector_\": "; vnx::write(_out, optional_vector_);
	_out << "}";
}

void TestValue::read(std::istream& _in) {
	if(auto _json = vnx::read_json(_in)) {
		from_object(_json->to_object());
	}
}

vnx::Object TestValue::to_object() const {
	vnx::Object _object;
	_object["__type"] = "vnx.test.TestValue";
	_object["bool_"] = bool_;
	_object["int_"] = int_;
	_object["double_"] = double_;
	_object["array_"] = array_;
	_object["struct_array_"] = struct_array_;
	_object["tmpl_array_"] = tmpl_array_;
	_object["string_"] = string_;
	_object["tuple_"] = tuple_;
	_object["user_tuple_"] = user_tuple_;
	_object["vector_"] = vector_;
	_object["user_vector_"] = user_vector_;
	_object["variant_vector_"] = variant_vector_;
	_object["enum_vector_"] = enum_vector_;
	_object["pair_vector_"] = pair_vector_;
	_object["set_"] = set_;
	_object["map_"] = map_;
	_object["variant_"] = variant_;
	_object["struct_"] = struct_;
	_object["enum_"] = enum_;
	_object["user_"] = user_;
	_object["pointer_"] = pointer_;
	_object["optional_int_"] = optional_int_;
	_object["optional_struct_"] = optional_struct_;
	_object["optional_enum_"] = optional_enum_;
	_object["optional_vector_"] = optional_vector_;
	return _object;
}

void TestValue::from_object(const vnx::Object& _object) {
	for(const auto& _entry : _object.field) {
		if(_entry.first == "array_") {
			_entry.second.to(array_);
		} else if(_entry.first == "bool_") {
			_entry.second.to(bool_);
		} else if(_entry.first == "double_") {
			_entry.second.to(double_);
		} else if(_entry.first == "enum_") {
			_entry.second.to(enum_);
		} else if(_entry.first == "enum_vector_") {
			_entry.second.to(enum_vector_);
		} else if(_entry.first == "int_") {
			_entry.second.to(int_);
		} else if(_entry.first == "map_") {
			_entry.second.to(map_);
		} else if(_entry.first == "optional_enum_") {
			_entry.second.to(optional_enum_);
		} else if(_entry.first == "optional_int_") {
			_entry.second.to(optional_int_);
		} else if(_entry.first == "optional_struct_") {
			_entry.second.to(optional_struct_);
		} else if(_entry.first == "optional_vector_") {
			_entry.second.to(optional_vector_);
		} else if(_entry.first == "pair_vector_") {
			_entry.second.to(pair_vector_);
		} else if(_entry.first == "pointer_") {
			_entry.second.to(pointer_);
		} else if(_entry.first == "set_") {
			_entry.second.to(set_);
		} else if(_entry.first == "string_") {
			_entry.second.to(string_);
		} else if(_entry.first == "struct_") {
			_entry.second.to(struct_);
		} else if(_entry.first == "struct_array_") {
			_entry.second.to(struct_array_);
		} else if(_entry.first == "tmpl_array_") {
			_entry.second.to(tmpl_array_);
		} else if(_entry.first == "tuple_") {
			_entry.second.to(tuple_);
		} else if(_entry.first == "user_") {
			_entry.second.to(user_);
		} else if(_entry.first == "user_tuple_") {
			_entry.second.to(user_tuple_);
		} else if(_entry.first == "user_vector_") {
			_entry.second.to(user_vector_);
		} else if(_entry.first == "variant_") {
			_entry.second.to(variant_);
		} else if(_entry.first == "variant_vector_") {
			_entry.second.to(variant_vector_);
		} else if(_entry.first == "vector_") {
			_entry.second.to(vector_);
		}
	}
}

vnx::Variant TestValue::get_field(const std::string& _name) const {
	if(_name == "bool_") {
		return vnx::Variant(bool_);
	}
	if(_name == "int_") {
		return vnx::Variant(int_);
	}
	if(_name == "double_") {
		return vnx::Variant(double_);
	}
	if(_name == "array_") {
		return vnx::Variant(array_);
	}
	if(_name == "struct_array_") {
		return vnx::Variant(struct_array_);
	}
	if(_name == "tmpl_array_") {
		return vnx::Variant(tmpl_array_);
	}
	if(_name == "string_") {
		return vnx::Variant(string_);
	}
	if(_name == "tuple_") {
		return vnx::Variant(tuple_);
	}
	if(_name == "user_tuple_") {
		return vnx::Variant(user_tuple_);
	}
	if(_name == "vector_") {
		return vnx::Variant(vector_);
	}
	if(_name == "user_vector_") {
		return vnx::Variant(user_vector_);
	}
	if(_name == "variant_vector_") {
		return vnx::Variant(variant_vector_);
	}
	if(_name == "enum_vector_") {
		return vnx::Variant(enum_vector_);
	}
	if(_name == "pair_vector_") {
		return vnx::Variant(pair_vector_);
	}
	if(_name == "set_") {
		return vnx::Variant(set_);
	}
	if(_name == "map_") {
		return vnx::Variant(map_);
	}
	if(_name == "variant_") {
		return vnx::Variant(variant_);
	}
	if(_name == "struct_") {
		return vnx::Variant(struct_);
	}
	if(_name == "enum_") {
		return vnx::Variant(enum_);
	}
	if(_name == "user_") {
		return vnx::Variant(user_);
	}
	if(_name == "pointer_") {
		return vnx::Variant(pointer_);
	}
	if(_name == "optional_int_") {
		return vnx::Variant(optional_int_);
	}
	if(_name == "optional_struct_") {
		return vnx::Variant(optional_struct_);
	}
	if(_name == "optional_enum_") {
		return vnx::Variant(optional_enum_);
	}
	if(_name == "optional_vector_") {
		return vnx::Variant(optional_vector_);
	}
	return vnx::Variant();
}

void TestValue::set_field(const std::string& _name, const vnx::Variant& _value) {
	if(_name == "bool_") {
		_value.to(bool_);
	} else if(_name == "int_") {
		_value.to(int_);
	} else if(_name == "double_") {
		_value.to(double_);
	} else if(_name == "array_") {
		_value.to(array_);
	} else if(_name == "struct_array_") {
		_value.to(struct_array_);
	} else if(_name == "tmpl_array_") {
		_value.to(tmpl_array_);
	} else if(_name == "string_") {
		_value.to(string_);
	} else if(_name == "tuple_") {
		_value.to(tuple_);
	} else if(_name == "user_tuple_") {
		_value.to(user_tuple_);
	} else if(_name == "vector_") {
		_value.to(vector_);
	} else if(_name == "user_vector_") {
		_value.to(user_vector_);
	} else if(_name == "variant_vector_") {
		_value.to(variant_vector_);
	} else if(_name == "enum_vector_") {
		_value.to(enum_vector_);
	} else if(_name == "pair_vector_") {
		_value.to(pair_vector_);
	} else if(_name == "set_") {
		_value.to(set_);
	} else if(_name == "map_") {
		_value.to(map_);
	} else if(_name == "variant_") {
		_value.to(variant_);
	} else if(_name == "struct_") {
		_value.to(struct_);
	} else if(_name == "enum_") {
		_value.to(enum_);
	} else if(_name == "user_") {
		_value.to(user_);
	} else if(_name == "pointer_") {
		_value.to(pointer_);
	} else if(_name == "optional_int_") {
		_value.to(optional_int_);
	} else if(_name == "optional_struct_") {
		_value.to(optional_struct_);
	} else if(_name == "optional_enum_") {
		_value.to(optional_enum_);
	} else if(_name == "optional_vector_") {
		_value.to(optional_vector_);
	}
}

/// \private
std::ostream& operator<<(std::ostream& _out, const TestValue& _value) {
	_value.write(_out);
	return _out;
}

/// \private
std::istream& operator>>(std::istream& _in, TestValue& _value) {
	_value.read(_in);
	return _in;
}

const vnx::TypeCode* TestValue::static_get_type_code() {
	const vnx::TypeCode* type_code = vnx::get_type_code(VNX_TYPE_HASH);
	if(!type_code) {
		type_code = vnx::register_type_code(static_create_type_code());
	}
	return type_code;
}

std::shared_ptr<vnx::TypeCode> TestValue::static_create_type_code() {
	auto type_code = std::make_shared<vnx::TypeCode>();
	type_code->name = "vnx.test.TestValue";
	type_code->type_hash = vnx::Hash64(0x8330d2d961c9571cull);
	type_code->code_hash = vnx::Hash64(0xb725c92956db303eull);
	type_code->is_native = true;
	type_code->is_class = true;
	type_code->native_size = sizeof(::vnx::test::TestValue);
	type_code->create_value = []() -> std::shared_ptr<vnx::Value> { return std::make_shared<TestValue>(); };
	type_code->depends.resize(3);
	type_code->depends[0] = ::vnx::test::test_struct_t::static_get_type_code();
	type_code->depends[1] = ::vnx::User::static_get_type_code();
	type_code->depends[2] = ::vnx::permission_e::static_get_type_code();
	type_code->fields.resize(25);
	{
		auto& field = type_code->fields[0];
		field.data_size = 1;
		field.name = "bool_";
		field.value = vnx::to_string(true);
		field.code = {31};
	}
	{
		auto& field = type_code->fields[1];
		field.data_size = 4;
		field.name = "int_";
		field.value = vnx::to_string(1337);
		field.code = {7};
	}
	{
		auto& field = type_code->fields[2];
		field.data_size = 8;
		field.name = "double_";
		field.value = vnx::to_string(1337.7331);
		field.code = {10};
	}
	{
		auto& field = type_code->fields[3];
		field.data_size = 16;
		field.name = "array_";
		field.code = {11, 4, 9};
	}
	{
		auto& field = type_code->fields[4];
		field.is_extended = true;
		field.name = "struct_array_";
		field.code = {11, 2, 19, 0};
	}
	{
		auto& field = type_code->fields[5];
		field.is_extended = true;
		field.name = "tmpl_array_";
		field.code = {11, 2, 33, 7};
	}
	{
		auto& field = type_code->fields[6];
		field.is_extended = true;
		field.name = "string_";
		field.value = vnx::to_string("test");
		field.code = {32};
	}
	{
		auto& field = type_code->fields[7];
		field.is_extended = true;
		field.name = "tuple_";
		field.code = {23, 4, 6, 7, 8, 9, 7, 9, 10, 32};
	}
	{
		auto& field = type_code->fields[8];
		field.is_extended = true;
		field.name = "user_tuple_";
		field.code = {23, 2, 4, 6, 19, 1, 19, 1};
	}
	{
		auto& field = type_code->fields[9];
		field.is_extended = true;
		field.name = "vector_";
		field.code = {12, 7};
	}
	{
		auto& field = type_code->fields[10];
		field.is_extended = true;
		field.name = "user_vector_";
		field.code = {12, 19, 1};
	}
	{
		auto& field = type_code->fields[11];
		field.is_extended = true;
		field.name = "variant_vector_";
		field.code = {12, 17};
	}
	{
		auto& field = type_code->fields[12];
		field.is_extended = true;
		field.name = "enum_vector_";
		field.code = {12, 19, 2};
	}
	{
		auto& field = type_code->fields[13];
		field.is_extended = true;
		field.name = "pair_vector_";
		field.code = {12, 23, 2, 4, 5, 7, 9};
	}
	{
		auto& field = type_code->fields[14];
		field.is_extended = true;
		field.name = "set_";
		field.code = {12, 32};
	}
	{
		auto& field = type_code->fields[15];
		field.is_extended = true;
		field.name = "map_";
		field.code = {13, 3, 32, 7};
	}
	{
		auto& field = type_code->fields[16];
		field.is_extended = true;
		field.name = "variant_";
		field.code = {17};
	}
	{
		auto& field = type_code->fields[17];
		field.is_extended = true;
		field.name = "struct_";
		field.code = {19, 0};
	}
	{
		auto& field = type_code->fields[18];
		field.is_extended = true;
		field.name = "enum_";
		field.value = vnx::to_string("VIEW");
		field.code = {19, 2};
	}
	{
		auto& field = type_code->fields[19];
		field.is_extended = true;
		field.name = "user_";
		field.code = {19, 1};
	}
	{
		auto& field = type_code->fields[20];
		field.is_extended = true;
		field.name = "pointer_";
		field.code = {16};
	}
	{
		auto& field = type_code->fields[21];
		field.is_extended = true;
		field.name = "optional_int_";
		field.code = {33, 7};
	}
	{
		auto& field = type_code->fields[22];
		field.is_extended = true;
		field.name = "optional_struct_";
		field.code = {33, 19, 0};
	}
	{
		auto& field = type_code->fields[23];
		field.is_extended = true;
		field.name = "optional_enum_";
		field.code = {33, 19, 2};
	}
	{
		auto& field = type_code->fields[24];
		field.is_extended = true;
		field.name = "optional_vector_";
		field.code = {33, 12, 23, 2, 4, 5, 7, 9};
	}
	type_code->build();
	return type_code;
}

std::shared_ptr<vnx::Value> TestValue::vnx_call_switch(std::shared_ptr<const vnx::Value> _method) {
	switch(_method->get_type_hash()) {
	}
	return nullptr;
}


} // namespace vnx
} // namespace test


namespace vnx {

void read(TypeInput& in, ::vnx::test::TestValue& value, const TypeCode* type_code, const uint16_t* code) {
	TypeInput::recursion_t tag(in);
	if(code) {
		switch(code[0]) {
			case CODE_OBJECT:
			case CODE_ALT_OBJECT: {
				Object tmp;
				vnx::read(in, tmp, type_code, code);
				value.from_object(tmp);
				return;
			}
			case CODE_DYNAMIC:
			case CODE_ALT_DYNAMIC:
				vnx::read_dynamic(in, value);
				return;
		}
	}
	if(!type_code) {
		vnx::skip(in, type_code, code);
		return;
	}
	if(code) {
		switch(code[0]) {
			case CODE_STRUCT: type_code = type_code->depends[code[1]]; break;
			case CODE_ALT_STRUCT: type_code = type_code->depends[vnx::flip_bytes(code[1])]; break;
			default: {
				vnx::skip(in, type_code, code);
				return;
			}
		}
	}
	const auto* const _buf = in.read(type_code->total_field_size);
	if(type_code->is_matched) {
		if(const auto* const _field = type_code->field_map[0]) {
			vnx::read_value(_buf + _field->offset, value.bool_, _field->code.data());
		}
		if(const auto* const _field = type_code->field_map[1]) {
			vnx::read_value(_buf + _field->offset, value.int_, _field->code.data());
		}
		if(const auto* const _field = type_code->field_map[2]) {
			vnx::read_value(_buf + _field->offset, value.double_, _field->code.data());
		}
		if(const auto* const _field = type_code->field_map[3]) {
			vnx::read_value(_buf + _field->offset, value.array_, _field->code.data());
		}
	}
	for(const auto* _field : type_code->ext_fields) {
		switch(_field->native_index) {
			case 4: vnx::read(in, value.struct_array_, type_code, _field->code.data()); break;
			case 5: vnx::read(in, value.tmpl_array_, type_code, _field->code.data()); break;
			case 6: vnx::read(in, value.string_, type_code, _field->code.data()); break;
			case 7: vnx::read(in, value.tuple_, type_code, _field->code.data()); break;
			case 8: vnx::read(in, value.user_tuple_, type_code, _field->code.data()); break;
			case 9: vnx::read(in, value.vector_, type_code, _field->code.data()); break;
			case 10: vnx::read(in, value.user_vector_, type_code, _field->code.data()); break;
			case 11: vnx::read(in, value.variant_vector_, type_code, _field->code.data()); break;
			case 12: vnx::read(in, value.enum_vector_, type_code, _field->code.data()); break;
			case 13: vnx::read(in, value.pair_vector_, type_code, _field->code.data()); break;
			case 14: vnx::read(in, value.set_, type_code, _field->code.data()); break;
			case 15: vnx::read(in, value.map_, type_code, _field->code.data()); break;
			case 16: vnx::read(in, value.variant_, type_code, _field->code.data()); break;
			case 17: vnx::read(in, value.struct_, type_code, _field->code.data()); break;
			case 18: vnx::read(in, value.enum_, type_code, _field->code.data()); break;
			case 19: vnx::read(in, value.user_, type_code, _field->code.data()); break;
			case 20: vnx::read(in, value.pointer_, type_code, _field->code.data()); break;
			case 21: vnx::read(in, value.optional_int_, type_code, _field->code.data()); break;
			case 22: vnx::read(in, value.optional_struct_, type_code, _field->code.data()); break;
			case 23: vnx::read(in, value.optional_enum_, type_code, _field->code.data()); break;
			case 24: vnx::read(in, value.optional_vector_, type_code, _field->code.data()); break;
			default: vnx::skip(in, type_code, _field->code.data());
		}
	}
}

void write(TypeOutput& out, const ::vnx::test::TestValue& value, const TypeCode* type_code, const uint16_t* code) {
	if(code && code[0] == CODE_OBJECT) {
		vnx::write(out, value.to_object(), nullptr, code);
		return;
	}
	if(!type_code || (code && code[0] == CODE_ANY)) {
		type_code = vnx::test::vnx_native_type_code_TestValue;
		out.write_type_code(type_code);
		vnx::write_class_header<::vnx::test::TestValue>(out);
	}
	else if(code && code[0] == CODE_STRUCT) {
		type_code = type_code->depends[code[1]];
	}
	auto* const _buf = out.write(29);
	vnx::write_value(_buf + 0, value.bool_);
	vnx::write_value(_buf + 1, value.int_);
	vnx::write_value(_buf + 5, value.double_);
	vnx::write_value(_buf + 13, value.array_);
	vnx::write(out, value.struct_array_, type_code, type_code->fields[4].code.data());
	vnx::write(out, value.tmpl_array_, type_code, type_code->fields[5].code.data());
	vnx::write(out, value.string_, type_code, type_code->fields[6].code.data());
	vnx::write(out, value.tuple_, type_code, type_code->fields[7].code.data());
	vnx::write(out, value.user_tuple_, type_code, type_code->fields[8].code.data());
	vnx::write(out, value.vector_, type_code, type_code->fields[9].code.data());
	vnx::write(out, value.user_vector_, type_code, type_code->fields[10].code.data());
	vnx::write(out, value.variant_vector_, type_code, type_code->fields[11].code.data());
	vnx::write(out, value.enum_vector_, type_code, type_code->fields[12].code.data());
	vnx::write(out, value.pair_vector_, type_code, type_code->fields[13].code.data());
	vnx::write(out, value.set_, type_code, type_code->fields[14].code.data());
	vnx::write(out, value.map_, type_code, type_code->fields[15].code.data());
	vnx::write(out, value.variant_, type_code, type_code->fields[16].code.data());
	vnx::write(out, value.struct_, type_code, type_code->fields[17].code.data());
	vnx::write(out, value.enum_, type_code, type_code->fields[18].code.data());
	vnx::write(out, value.user_, type_code, type_code->fields[19].code.data());
	vnx::write(out, value.pointer_, type_code, type_code->fields[20].code.data());
	vnx::write(out, value.optional_int_, type_code, type_code->fields[21].code.data());
	vnx::write(out, value.optional_struct_, type_code, type_code->fields[22].code.data());
	vnx::write(out, value.optional_enum_, type_code, type_code->fields[23].code.data());
	vnx::write(out, value.optional_vector_, type_code, type_code->fields[24].code.data());
}

void read(std::istream& in, ::vnx::test::TestValue& value) {
	value.read(in);
}

void write(std::ostream& out, const ::vnx::test::TestValue& value) {
	value.write(out);
}

void accept(Visitor& visitor, const ::vnx::test::TestValue& value) {
	value.accept(visitor);
}

} // vnx
